___
1. **Explain what is meant by the stream abstraction. What is the relationship between streams and the observer pattern? What are streams useful for modelling and when might you use them in Rich Web development?**
		A stream is a representation of a sequence of bytes which could represent a file or input/output device. When talking about rich web applications, stream abstraction means the separation of the processing logic from the input.
		The observer pattern uses events to inform subscribed entities that a change has occurred in an observable. The relationship between streams and the observer pattern is that the observable sends events as streams to observers if they are subscribed to the observable.
		Streams can be very useful for dealing with asynchronous tasks, such as processing data as soon as it is available to the client without the need for buffers. It can allow for large amounts of data to be processed in smaller and more manageable chunks, preventing the main processing thread from being slowed or blocked. In rich web development, an example of this would be exchanging information between multiple applications. Small chunks of data can be sent without waiting for full context, e.g. in applications involving video streaming.
2. **Assume that you are building an interface to an API in your Rich Web App. Describe in detail how you could use the RxJS library to handle asynchronous network responses to API requests. In your opinion, what are the benefits to using a streams library for networking over, say, promises? And what do you think are the downsides?**
		First, using the RxHR object I can generate API calls as it handles HTTP methods such as GET, POST, PUT etc. and returns an observable.
		`const observ = RxHR.get('example.api/data')`
		Then I would handle the response from this call by subscribing to the observable. Here I can transform the data how I wish and also handle any errors that might occur resulting from the incoming data.
		`observ.subscribe(...)`
		At this point, many other functions such as `map()` or `tap()` can be used to manipulate the data to the purpose of your application.
		In my opinion, RxJS provides a stream library that can allow for data to be easily handled, maintained and manipulated due to the wide availability of operators. Observables can also be used to return multiple values at once, whereas promises are limited to one. Observables can also be unsubscribed to at any point, which promises do not allow.
		In terms of downsides, streams and observables can have a higher learning curve to them as they can be difficult to understand when compared to promises. Another downside would be in smaller applications or projects, it may be less useful and more effort to use streams when compared to promises, especially when handling simpler tasks.
3. **Consider three asynchronous tasks, A,B & C. What are the consequences of these functions sharing global state? What is a good practice to alleviate any problems associated with this**
		In this scenario, if tasks A and B both tried to access or modify the same global resource or state at the same time it could lead to concurrency issues across the application. Another thing to consider would be Race Conditions. If one task altered the global state that another task depends on, it will lead to inconsistent results, or unexpected outcomes in what the tasks were meant to achieve.
		To avoid these issues, there are a few practices to consider implementing. Firstly, avoid using global state and instead pass state directly to the functions themselves. If the tasks are started by one function, defining local variables inside the function that the completion handlers for the async functions can access will prevent global state from being altered. Alternatively if you are using global state, making the data immutable will help prevent problems.